for (zt_index in 1:number_of_z_values)
{
# Solve the Value Function and Policy Function and update values.
result = Solve_HH_Problem(Value_Function[iteration-1, , ], kt0_index, zt_index, params)
Value_Function[iteration,kt0_index,zt_index] = result$v_max
Policy_Function[iteration,kt0_index,zt_index] = result$kt1_optimal
}
}
}
# -----------------------------------------------------------------------------------------------------
# 4 - Plot results.
# -----------------------------------------------------------------------------------------------------
# Plot the Value Function for different starting states.
plot(c(min(k_values), max(k_values)),
c(min(Value_Function[number_of_iterations, , ]), (Value_Function[number_of_iterations, , ])),
type="l", col="white", # hidden values to establish plot size
main="Value Function", xlab="k", ylab="V(k,z)")
for (z_index in 1:number_of_z_values)
{
lines(k_values, Value_Function[number_of_iterations, ,z_index])
}
legend("right", legend=round(rev(z_values), 2), title="z values")
# Plot the final Policy Function for certain productivity values.
z_indices = c(1, 4, 6, 8, 11)
plot(k_values, k_values, type="l", lty=2, col="black",
main="Policy Function", xlab="k", ylab="g(k)")
for (z_index in z_indices){
lines(k_values, Policy_Function[number_of_iterations, , z_index])
}
legend("topleft", legend=c(round(rev(z_values[z_indices]), 2), "45-degree line"),
lty=c(1, 1, 1, 1, 1, 2), title="z values")
# Assign parameter values.
alpha = 0.400
beta  = 0.987
delta = 0.012
number_of_iterations = 1000
# Calculate the steady-state level of capital.
k_steady = ((1 - beta * (1 - delta)) / (alpha * beta)) ^ (1 / (alpha - 1))
# Create a range of capital values around steady-state (+/- 2%).
number_of_k_values = 201
k_low_pct = 0.98
k_high_pct = 1.02
k_values = seq(k_low_pct * k_steady, k_high_pct * k_steady, length.out=number_of_k_values)
# Get productivity levels and transition probabilities.
z_probs = as.matrix(read.csv("Inputs/z_probs.csv", sep=",", header=FALSE))
z_values = as.matrix(read.csv("Inputs/z_values.csv", sep=",", header=FALSE))
number_of_z_values = dim(z_values)[1]
# Initialize the Value Function and Policy Function (as arrays).
Value_Function = array(0, c(number_of_iterations, number_of_k_values, number_of_z_values))
number_of_z_values = dim(z_values)[1]
Policy_Function = array(0, c(number_of_iterations, number_of_k_values, number_of_z_values))
# Store utility parameters and capital/productivity grids in a list for passing to a function.
params = list(alpha=alpha, beta=beta, delta=delta,
k_values=k_values, z_values=z_values, z_probs=z_probs)
Solve_HH_Problem = function(Value_Function, kt0_index, zt_index, params){
# Unpack utility parameters and grids.
alpha = params$alpha
beta = params$beta
delta = params$delta
k_values = params$k_values
z_values = params$z_values
z_probs = params$z_probs
# Get capital and productivity values from index.
kt0 = k_values[kt0_index]
zt = z_values[zt_index]
# Calculate array of value function values for all capital values.
V_max_values = log(zt * (kt0 ^ alpha) + (1 - delta) * kt0 - k_values) +
beta * drop(Previous_Value_Function %*% z_probs[zt_index, ])
# Get the index for the optimal capital choice.
kt1_index_optimal = which.max(V_max_values)
# Get the Value Function and Policy Function values.
kt1_optimal = k_values[kt1_index_optimal]
v_max = V_max_values[kt1_index_optimal]
return(list(v_max=v_max, kt1_optimal=kt1_optimal))
}
for (iteration in 2:number_of_iterations)
{
# Loop over all possible starting states.
for (kt0_index in 1:number_of_k_values)
{
for (zt_index in 1:number_of_z_values)
{
# Solve the Value Function and Policy Function and update values.
result = Solve_HH_Problem(Value_Function[iteration-1, , ], kt0_index, zt_index, params)
Value_Function[iteration,kt0_index,zt_index] = result$v_max
Policy_Function[iteration,kt0_index,zt_index] = result$kt1_optimal
}
}
}
# Stochastic Growth model implemented in R.
#
# Steps:
#     1 - Define utility parameters, grids, and parameter struct.
#     2 - Create a function to solve the household's problem for a given starting state.
#     3 - Perform value function iteration.
#     4 - Plot results.
# -----------------------------------------------------------------------------------------------------
# 1 - Define utility parameters, grids, and parameter struct.
# -----------------------------------------------------------------------------------------------------
# Assign parameter values.
alpha = 0.400
beta  = 0.987
delta = 0.012
number_of_iterations = 1000
# Calculate the steady-state level of capital.
k_steady = ((1 - beta * (1 - delta)) / (alpha * beta)) ^ (1 / (alpha - 1))
# Create a range of capital values around steady-state (+/- 2%).
number_of_k_values = 201
k_low_pct = 0.98
k_high_pct = 1.02
k_values = seq(k_low_pct * k_steady, k_high_pct * k_steady, length.out=number_of_k_values)
# Get productivity levels and transition probabilities.
z_probs = as.matrix(read.csv("Inputs/z_probs.csv", sep=",", header=FALSE))
z_values = as.matrix(read.csv("Inputs/z_values.csv", sep=",", header=FALSE))
number_of_z_values = dim(z_values)[1]
# Initialize the Value Function and Policy Function (as arrays).
Value_Function = array(0, c(number_of_iterations, number_of_k_values, number_of_z_values))
Policy_Function = array(0, c(number_of_iterations, number_of_k_values, number_of_z_values))
# Store utility parameters and capital/productivity grids in a list for passing to a function.
params = list(alpha=alpha, beta=beta, delta=delta,
k_values=k_values, z_values=z_values, z_probs=z_probs)
# -----------------------------------------------------------------------------------------------------
# 2 - Create a function to solve Value Function for given starting states.
# -----------------------------------------------------------------------------------------------------
Solve_HH_Problem = function(Value_Function, kt0_index, zt_index, params){
# Unpack utility parameters and grids.
alpha = params$alpha
beta = params$beta
delta = params$delta
k_values = params$k_values
z_values = params$z_values
z_probs = params$z_probs
# Get capital and productivity values from index.
kt0 = k_values[kt0_index]
zt = z_values[zt_index]
# Calculate array of value function values for all capital values.
V_max_values = log(zt * (kt0 ^ alpha) + (1 - delta) * kt0 - k_values) +
beta * drop(Value_Function %*% z_probs[zt_index, ])
# Get the index for the optimal capital choice.
kt1_index_optimal = which.max(V_max_values)
# Get the Value Function and Policy Function values.
kt1_optimal = k_values[kt1_index_optimal]
v_max = V_max_values[kt1_index_optimal]
return(list(v_max=v_max, kt1_optimal=kt1_optimal))
}
# Alternative: import other versions from script.
# source("custom_functions")
# use Solve_HH_Problem_v1 or Solve_HH_Problem_v2
# -----------------------------------------------------------------------------------------------------
# 3 - Perform value function iteration.
# -----------------------------------------------------------------------------------------------------
for (iteration in 2:number_of_iterations)
{
# Loop over all possible starting states.
for (kt0_index in 1:number_of_k_values)
{
for (zt_index in 1:number_of_z_values)
{
# Solve the Value Function and Policy Function and update values.
result = Solve_HH_Problem(Value_Function[iteration-1, , ], kt0_index, zt_index, params)
Value_Function[iteration,kt0_index,zt_index] = result$v_max
Policy_Function[iteration,kt0_index,zt_index] = result$kt1_optimal
}
}
}
# -----------------------------------------------------------------------------------------------------
# 4 - Plot results.
# -----------------------------------------------------------------------------------------------------
# Plot the Value Function for different starting states.
plot(c(min(k_values), max(k_values)),
c(min(Value_Function[number_of_iterations, , ]), (Value_Function[number_of_iterations, , ])),
type="l", col="white", # hidden values to establish plot size
main="Value Function", xlab="k", ylab="V(k,z)")
for (z_index in 1:number_of_z_values)
{
lines(k_values, Value_Function[number_of_iterations, ,z_index])
}
legend("right", legend=round(rev(z_values), 2), title="z values")
# Plot the final Policy Function for certain productivity values.
z_indices = c(1, 4, 6, 8, 11)
plot(k_values, k_values, type="l", lty=2, col="black",
main="Policy Function", xlab="k", ylab="g(k)")
for (z_index in z_indices){
lines(k_values, Policy_Function[number_of_iterations, , z_index])
}
legend("topleft", legend=c(round(rev(z_values[z_indices]), 2), "45-degree line"),
lty=c(1, 1, 1, 1, 1, 2), title="z values")
# Idiosyncratic Endowment model implemented in R.
# Steps:
#   1 - Define utility parameters, grids, and parameter struct.
#   2 - Solve model and get market bond price using binary search.
#       - Guess bond price
#       - Solve for the Value Function and Policy Function
#       - Get the distribution of credit and productivity levels
#       - Check the market clearing condition and update bond price guess
#   3 - Plot results.
source("custom_functions.R")
# Endowment parameters.
e_high = 1.0                                                # high endowment
e_low  = 0.1                                                # low endowment
e_grid = c(e_low, e_high)                                   # endowment grid
number_of_e_values = 2
e_probs = matrix(c(0.500, 0.500, 0.075, 0.925),
byrow=T, ncol=2)                           # transition probabilities
# Utility parameters.
sigma = 1.5                                                 # risk aversion coefficient
beta  = 0.99322                                             # discount factor
# Credit parameters.
a_high = 4                                                  # upper credit limit
a_low  = -2                                                 # lower credit limit / borrowing constraint
number_of_a_values = 100                                   # credit grid size
a_grid = seq(a_low, a_high, length.out=number_of_a_values)  # credit grid
# Store parameters in a named list for passing to a function.
params = list(sigma   = sigma,
beta    = beta,
a_grid  = a_grid,
e_grid  = e_grid,
e_probs = e_probs,
number_of_a_values = number_of_a_values,
number_of_e_values = number_of_e_values)
# -----------------------------------------------------------------------------------------------------
# 2 - Solve model and get market bond price using binary search.
# -----------------------------------------------------------------------------------------------------
# Range of bond price values to search.
q_min = 0.985
q_max = 1.100
# Optional: floor for q_min such that those at credit limit can still afford positive consumption.
q_min = (a_low + e_low) / a_low
# Placeholder for the market clearing condition.
mcc = Inf;
# Iteration parameters.
dist = Inf
iteration_count = 0
max_iterations = 20
tolerance = 1e-3
# Solve for market price q.
while ((dist > tolerance) & (iteration_count < max_iterations))
{
# Get value of q from middle of range.
q = (q_min + q_max)/2
# Solve for the Value Function and Policy Function.
vf_result = Solve_Value_Function(q, params)
# Get the Population Distribution.
Population_Distribution = Get_Population_Distribution(vf_result$Policy_Function_Index, params)
# Check the market clearing condition.
mcc = sum(vf_result$Policy_Function * Population_Distribution)
# Update search parameters.
dist = abs(mcc)
iteration_count = iteration_count + 1
# Update range of q according to the sign of the market clearing condition.
if (mcc > 0) { q_min = q }
if (mcc < 0) { q_max = q }
# Print results.
print(sprintf("Iteration %s: q=%f, mcc=%f", iteration_count, round(q, digits=6), round(mcc, digits=6)))
if (iteration_count >= max_iterations)
{
print(sprintf("Warning: search for q did not converge after %s iterations", iteration_count))
}
}
# -----------------------------------------------------------------------------------------------------
# 3 - Plot results.
# -----------------------------------------------------------------------------------------------------
# Policy functions (Figure 1. from Huggett 1993).
plot(c(-2, 1),c(-2, 1), type="l", col="white",
main="Policy Function", xlab="starting credit level", ylab="optimal new credit level")
lines(a_grid, vf_result$Policy_Function[ , 2], col="blue")
lines(a_grid, vf_result$Policy_Function[ , 1], col="green")
lines(a_grid, a_grid, lty=2, col="black")
legend("bottomright", legend = c("high endowment", "low endowment", "45-degree line"))
# Distribution of credit levels (Figure 2. from Huggett 1993).
plot(c(-2, 1),c(0, 1), type="l", col="white",
main="Cumulative Distribution Function for Credit Level", xlab="starting credit level", ylab="")
lines(a_grid, cumsum(Population_Distribution[ , 2]), col="blue")
lines(a_grid, cumsum(Population_Distribution[ , 1]), col="green")
legend("topleft", legend=c("high endowment", "low endowment"), col=c("blue","green"))
source("custom_functions.R")
# Endowment parameters.
e_high = 1.0                                                # high endowment
e_low  = 0.1                                                # low endowment
e_grid = c(e_low, e_high)                                   # endowment grid
number_of_e_values = 2
e_probs = matrix(c(0.500, 0.500, 0.075, 0.925),
byrow=T, ncol=2)                           # transition probabilities
# Utility parameters.
sigma = 1.5                                                 # risk aversion coefficient
beta  = 0.99322                                             # discount factor
# Credit parameters.
a_high = 4                                                  # upper credit limit
a_low  = -2                                                 # lower credit limit / borrowing constraint
number_of_a_values = 100                                   # credit grid size
a_grid = seq(a_low, a_high, length.out=number_of_a_values)  # credit grid
# Store parameters in a named list for passing to a function.
params = list(sigma   = sigma,
beta    = beta,
a_grid  = a_grid,
e_grid  = e_grid,
e_probs = e_probs,
number_of_a_values = number_of_a_values,
number_of_e_values = number_of_e_values)
# Range of bond price values to search.
q_min = 0.985
q_max = 1.100
# Optional: floor for q_min such that those at credit limit can still afford positive consumption.
q_min = (a_low + e_low) / a_low
# Placeholder for the market clearing condition.
mcc = Inf;
# Iteration parameters.
dist = Inf
iteration_count = 0
max_iterations = 20
tolerance = 1e-3
# Solve for market price q.
while ((dist > tolerance) & (iteration_count < max_iterations))
{
# Get value of q from middle of range.
q = (q_min + q_max)/2
# Solve for the Value Function and Policy Function.
vf_result = Solve_Value_Function(q, params)
# Get the Population Distribution.
Population_Distribution = Get_Population_Distribution(vf_result$Policy_Function_Index, params)
# Check the market clearing condition.
mcc = sum(vf_result$Policy_Function * Population_Distribution)
# Update search parameters.
dist = abs(mcc)
iteration_count = iteration_count + 1
# Update range of q according to the sign of the market clearing condition.
if (mcc > 0) { q_min = q }
if (mcc < 0) { q_max = q }
# Print results.
print(sprintf("Iteration %s: q=%f, mcc=%f", iteration_count, round(q, digits=6), round(mcc, digits=6)))
if (iteration_count >= max_iterations)
{
print(sprintf("Warning: search for q did not converge after %s iterations", iteration_count))
}
}
setwd("~/GitHub/DSGE-models/3 - Idiosyncratic Endowment/R")
# Idiosyncratic Endowment model implemented in R.
# Steps:
#   1 - Define utility parameters, grids, and parameter struct.
#   2 - Solve model and get market bond price using binary search.
#       - Guess bond price
#       - Solve for the Value Function and Policy Function
#       - Get the distribution of credit and productivity levels
#       - Check the market clearing condition and update bond price guess
#   3 - Plot results.
source("custom_functions.R")
# Endowment parameters.
e_high = 1.0                                                # high endowment
e_low  = 0.1                                                # low endowment
e_grid = c(e_low, e_high)                                   # endowment grid
number_of_e_values = 2
e_probs = matrix(c(0.500, 0.500, 0.075, 0.925),
byrow=T, ncol=2)                           # transition probabilities
# Utility parameters.
sigma = 1.5                                                 # risk aversion coefficient
beta  = 0.99322                                             # discount factor
# Credit parameters.
a_high = 4                                                  # upper credit limit
a_low  = -2                                                 # lower credit limit / borrowing constraint
number_of_a_values = 100                                   # credit grid size
a_grid = seq(a_low, a_high, length.out=number_of_a_values)  # credit grid
# Store parameters in a named list for passing to a function.
params = list(sigma   = sigma,
beta    = beta,
a_grid  = a_grid,
e_grid  = e_grid,
e_probs = e_probs,
number_of_a_values = number_of_a_values,
number_of_e_values = number_of_e_values)
# -----------------------------------------------------------------------------------------------------
# 2 - Solve model and get market bond price using binary search.
# -----------------------------------------------------------------------------------------------------
# Range of bond price values to search.
q_min = 0.985
q_max = 1.100
# Optional: floor for q_min such that those at credit limit can still afford positive consumption.
q_min = (a_low + e_low) / a_low
# Placeholder for the market clearing condition.
mcc = Inf;
# Iteration parameters.
dist = Inf
iteration_count = 0
max_iterations = 20
tolerance = 1e-3
# Solve for market price q.
while ((dist > tolerance) & (iteration_count < max_iterations))
{
# Get value of q from middle of range.
q = (q_min + q_max)/2
# Solve for the Value Function and Policy Function.
vf_result = Solve_Value_Function(q, params)
# Get the Population Distribution.
Population_Distribution = Get_Population_Distribution(vf_result$Policy_Function_Index, params)
# Check the market clearing condition.
mcc = sum(vf_result$Policy_Function * Population_Distribution)
# Update search parameters.
dist = abs(mcc)
iteration_count = iteration_count + 1
# Update range of q according to the sign of the market clearing condition.
if (mcc > 0) { q_min = q }
if (mcc < 0) { q_max = q }
# Print results.
print(sprintf("Iteration %s: q=%f, mcc=%f", iteration_count, round(q, digits=6), round(mcc, digits=6)))
if (iteration_count >= max_iterations)
{
print(sprintf("Warning: search for q did not converge after %s iterations", iteration_count))
}
}
# -----------------------------------------------------------------------------------------------------
# 3 - Plot results.
# -----------------------------------------------------------------------------------------------------
# Policy functions (Figure 1. from Huggett 1993).
plot(c(-2, 1),c(-2, 1), type="l", col="white",
main="Policy Function", xlab="starting credit level", ylab="optimal new credit level")
lines(a_grid, vf_result$Policy_Function[ , 2], col="blue")
lines(a_grid, vf_result$Policy_Function[ , 1], col="green")
lines(a_grid, a_grid, lty=2, col="black")
legend("bottomright", legend = c("high endowment", "low endowment", "45-degree line"))
# Distribution of credit levels (Figure 2. from Huggett 1993).
plot(c(-2, 1),c(0, 1), type="l", col="white",
main="Cumulative Distribution Function for Credit Level", xlab="starting credit level", ylab="")
lines(a_grid, cumsum(Population_Distribution[ , 2]), col="blue")
lines(a_grid, cumsum(Population_Distribution[ , 1]), col="green")
legend("topleft", legend=c("high endowment", "low endowment"), col=c("blue","green"))
# Idiosyncratic Endowment model implemented in R.
# Steps:
#   1 - Define utility parameters, grids, and parameter struct.
#   2 - Solve model and get market bond price using binary search.
#       - Guess bond price
#       - Solve for the Value Function and Policy Function
#       - Get the distribution of credit and productivity levels
#       - Check the market clearing condition and update bond price guess
#   3 - Plot results.
source("custom_functions.R")
# Endowment parameters.
e_high = 1.0                                                # high endowment
e_low  = 0.1                                                # low endowment
e_grid = c(e_low, e_high)                                   # endowment grid
number_of_e_values = 2
e_probs = matrix(c(0.500, 0.500, 0.075, 0.925),
byrow=T, ncol=2)                           # transition probabilities
# Utility parameters.
sigma = 1.5                                                 # risk aversion coefficient
beta  = 0.99322                                             # discount factor
# Credit parameters.
a_high = 4                                                  # upper credit limit
a_low  = -2                                                 # lower credit limit / borrowing constraint
number_of_a_values = 100                                   # credit grid size
a_grid = seq(a_low, a_high, length.out=number_of_a_values)  # credit grid
# Store parameters in a named list for passing to a function.
params = list(sigma   = sigma,
beta    = beta,
a_grid  = a_grid,
e_grid  = e_grid,
e_probs = e_probs,
number_of_a_values = number_of_a_values,
number_of_e_values = number_of_e_values)
# -----------------------------------------------------------------------------------------------------
# 2 - Solve model and get market bond price using binary search.
# -----------------------------------------------------------------------------------------------------
# Range of bond price values to search.
q_min = 0.985
q_max = 1.100
# Optional: floor for q_min such that those at credit limit can still afford positive consumption.
q_min = (a_low + e_low) / a_low
# Placeholder for the market clearing condition.
mcc = Inf;
# Iteration parameters.
dist = Inf
iteration_count = 0
max_iterations = 20
tolerance = 1e-3
# Solve for market price q.
while ((dist > tolerance) & (iteration_count < max_iterations))
{
# Get value of q from middle of range.
q = (q_min + q_max)/2
# Solve for the Value Function and Policy Function.
vf_result = Solve_Value_Function(q, params)
# Get the Population Distribution.
Population_Distribution = Get_Population_Distribution(vf_result$Policy_Function_Index, params)
# Check the market clearing condition.
mcc = sum(vf_result$Policy_Function * Population_Distribution)
# Update search parameters.
dist = abs(mcc)
iteration_count = iteration_count + 1
# Update range of q according to the sign of the market clearing condition.
if (mcc > 0) { q_min = q }
if (mcc < 0) { q_max = q }
# Print results.
print(sprintf("Iteration %s: q=%f, mcc=%f", iteration_count, round(q, digits=6), round(mcc, digits=6)))
if (iteration_count >= max_iterations)
{
print(sprintf("Warning: search for q did not converge after %s iterations", iteration_count))
}
}
# -----------------------------------------------------------------------------------------------------
# 3 - Plot results.
# -----------------------------------------------------------------------------------------------------
# Policy functions (Figure 1. from Huggett 1993).
plot(c(-2, 1),c(-2, 1), type="l", col="white",
main="Policy Function", xlab="starting credit level", ylab="optimal new credit level")
lines(a_grid, vf_result$Policy_Function[ , 2], col="blue")
lines(a_grid, vf_result$Policy_Function[ , 1], col="green")
lines(a_grid, a_grid, lty=2, col="black")
legend("bottomright", legend = c("high endowment", "low endowment", "45-degree line"))
# Distribution of credit levels (Figure 2. from Huggett 1993).
plot(c(-2, 1),c(0, 1), type="l", col="white",
main="Cumulative Distribution Function for Credit Level", xlab="starting credit level", ylab="")
lines(a_grid, cumsum(Population_Distribution[ , 2]), col="blue")
lines(a_grid, cumsum(Population_Distribution[ , 1]), col="green")
legend("topleft", legend=c("high endowment", "low endowment"), col=c("blue","green"))
